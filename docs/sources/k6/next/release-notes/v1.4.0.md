---
title: Version 1.4.0 release notes
menuTitle: v1.4.0
description: The release notes for Grafana k6 version 1.4.0
weight: 9985
---

# Version 1.4.0 release notes

<!-- md-k6:skipall -->

k6 `v1.4.0` is here ðŸŽ‰! This release includes:

- OpenTelemetry output graduated from experimental to stable status.
- Changes in the Browser module:
  - `page.waitForRequest` for waiting on specific HTTP requests.
  - `QueryAll` methods now return elements in DOM order.
  - `locator.evaluate` and `locator.evaluateHandle` for executing JavaScript code in the page context with access to the matching element.
  - `page.unroute(url)` and `page.unrouteAll` for removing routes registered with `page.route`.

## Breaking changes

As per our [stability guarantees](https://grafana.com/docs/k6/latest/reference/versioning-and-stability-guarantees/), breaking changes across minor releases are allowed only for experimental features.

### Breaking changes for experimental modules

- [#5164](https://github.com/grafana/k6/pull/5164) OpenTelemetry output now exports rate metrics as a single counter with `zero`/`nonzero` labels instead of separate metrics.
- [#5333](https://github.com/grafana/k6/pull/5333) OpenTelemetry output configuration: `K6_OTEL_EXPORTER_TYPE` is deprecated in favor of `K6_OTEL_EXPORTER_PROTOCOL` to align with OpenTelemetry standards.

### Breaking changes for undefined behaviours
- [#5320](https://github.com/grafana/k6/pull/5320), [#5239](https://github.com/grafana/k6/pull/5239), [#5342](https://github.com/grafana/k6/pull/5342) Automatic extension resolution now only inspects ES module `import` statements and no longer supports CommonJS `require()` calls. CommonJS `require()` calls are dynamic, and it is not possible to know for certain if they will be called, or if they will be called with static strings - the only way they were even previously loaded. This functionality was a quirk of the previous implementation and had numerous problems. Additionally, `use k6` directives are now only recognized when they appear at the beginning of files (after optional shebang and whitespace/comments). This was the original intention, but due to implementation bugs, it did not accurately reflect what was happening.

## New features

### OpenTelemetry output graduation [#5334](https://github.com/grafana/k6/pull/5334)

The OpenTelemetry output has graduated from experimental status and is now available as a stable output using the name `opentelemetry`. This change makes OpenTelemetry the recommended vendor-agnostic solution for exporting k6 telemetry data.

You can now use the stable output name in your k6 commands:

```bash
# Previous experimental usage (still supported for backward compatibility)
k6 run --out experimental-opentelemetry script.js

# New stable usage
k6 run --out opentelemetry script.js
```

The `experimental-opentelemetry` name will continue to work for backward compatibility for now but it's deprecated and we might remove it in future versions. We recommend migrating to use the new `opentelemetry` name.

### `page.waitForRequest` [#5330](https://github.com/grafana/k6/pull/5330)

The browser module now supports [`page.waitForRequest()`](https://grafana.com/docs/k6/latest/javascript-api/k6-browser/page/waitforrequest/), which allows you to wait for HTTP requests that match specific URL patterns during browser automation. This method is particularly valuable for testing scenarios where you need to ensure specific network requests are initiated before proceeding with test actions.

The method supports multiple URL pattern matching strategies:

```javascript
// Wait for exact URL match
const requestPromise = page.waitForRequest('https://api.example.com/data');
await page.click('button[data-testid="load-data"]');
const request = await requestPromise;

// Wait for regex pattern match
await page.waitForRequest(/\/api\/.*\.json$/);

// Use with Promise.all for coordinated actions
await Promise.all([
  page.waitForRequest('https://api.example.com/user-data'),
  page.click('button[data-testid="load-user-data"]')
]);
```

This complements the existing [`page.waitForResponse()`](https://grafana.com/docs/k6/latest/javascript-api/k6-browser/page/waitforresponse/) method by focusing on HTTP requests rather than responses, providing more granular control over network-dependent test scenarios.

### `page.unroute(url)` and `page.unrouteAll()` [#5223](https://github.com/grafana/k6/pull/5223)

The browser module now supports [`page.unroute(url)`](https://grafana.com/docs/k6/latest/javascript-api/k6-browser/page/unroute/) and [`page.unrouteAll()`](https://grafana.com/docs/k6/latest/javascript-api/k6-browser/page/unrouteall/), allowing you to remove routes previously registered with `page.route`.

Example usage:
```javascript
await page.route(/.*\/api\/pizza/, function (route) {
  console.log('Modifying request to /api/pizza');
  route.continue({
    postData: JSON.stringify({
      customName: 'My Pizza',
    }),
  });
});
...

await page.unroute(/.*\/api\/pizza/); // The URL needs to be exactly the same as the one used in the call to the `route` function
```

```javascript
await page.route(/.*\/api\/pizza/, function (route) {
  console.log('Modifying request to /api/pizza');
  route.continue({
    postData: JSON.stringify({
      customName: 'My Pizza',
    }),
  });
});
...

await page.unrouteAll();
```

### `locator.evaluate` and `locator.evaluateHandle` [#5306](https://github.com/grafana/k6/pull/5306)

The browser module now supports [`locator.evaluate`](https://grafana.com/docs/k6/latest/javascript-api/k6-browser/locator/evaluate/) and [`locator.evaluateHandle`](https://grafana.com/docs/k6/latest/javascript-api/k6-browser/locator/evaluatehandle/), allowing you to execute JavaScript code in the page context with access to the matching element. The only difference between `evaluate` and `evaluateHandle` is that `evaluateHandle` returns a [JSHandle](https://grafana.com/docs/k6/latest/javascript-api/k6-browser/jshandle/).

Example usage:
```javascript
await check(page, {
  'calling evaluate': async p => {
    const n = await p.locator('#pizza-name').evaluate(pizzaName => pizzaName.textContent);
    return n == 'Our recommendation:';
  }
});

await check(page, {
  'calling evaluate with arguments': async p => {
    const n = await p.locator('#pizza-name').evaluate((pizzaName, extra) => pizzaName.textContent + extra, ' Super pizza!');
    return n == 'Our recommendation: Super pizza!';
  }
});
```

```javascript
const jsHandle = await page.locator('#pizza-name').evaluateHandle((pizzaName) => pizzaName);

const obj = await jsHandle.evaluateHandle((handle) => {
  return { innerText: handle.innerText };
});
console.log(await obj.jsonValue()); // {"innerText":"Our recommendation:"}
```

### New officially supported [k6 DNS extension](https://github.com/grafana/xk6-dns)

The [`xk6-dns` extension](https://grafana.com/docs/k6/latest/javascript-api/k6-x-dns) is now officially supported in k6 OSS and k6 Cloud. You can import `k6/x/dns` directly in your scripts thanks to [automatic extension resolution](https://grafana.com/docs/grafana-cloud/testing/k6/author-run/use-k6-extensions/), with no custom build required.

Use it to perform DNS resolution testing as part of your tests: resolve names via custom or system DNS, measure resolution latency and errors, validate records before HTTP steps, compare resolvers, and even load test DNS servers in endâ€‘toâ€‘end scenarios.

For example:

```javascript
import dns from 'k6/x/dns';

export default function () {
  const answer = dns.resolve('grafana.com', { recordType: 'A' });
  console.log(answer.records.map(({ address }) => address).join(', '));
}
```

The extension currently supports A and AAAA record lookups. If you would like to see additional record types supported, please consider [contributing to the extension](https://github.com/grafana/xk6-dns).


### Automatic extension resolution improvements [#5320](https://github.com/grafana/k6/pull/5320), [#5239](https://github.com/grafana/k6/pull/5239), [#5342](https://github.com/grafana/k6/pull/5342), [#5332](https://github.com/grafana/k6/pull/5332), [#5240](https://github.com/grafana/k6/pull/5240)

Automatic extension resolution has been completely reimplemented to use k6's internal module loader instead of the external `k6deps`/esbuild pipeline. This change brings significant improvements in reliability and maintainability.

As part of the rewrite, a few issues and unintended _features_ were found, namely:
1. Trying to follow `require` calls, which, due to their dynamic nature, don't work particularly stably. That is, depending on where and how the `require` call was used, k6 might decide whether it is needed or not. And it definitely doesn't work when using actual string variables. Support for CommonJS is primarily for backward compatibility, so after an internal discussion, we opted not to support it at all. We could bring this back until v2, if there is enough interest. However, in the long term, it is intended that this not be part of k6.
2. "use k6 with ..." directives were parsed from the whole file instead of just the beginning, which leads to numerous problems, and was not the intended case. As such, they are now only parsed at the beginning of files (not just the main one) with potential empty lines and comments preceding them.

**Example:**

```javascript
// main.js
"use k6 with k6/x/faker"
import { faker } from 'k6/x/faker';
import { helper } from './utils.js';

export default function() {
  console.log(faker.name());
  helper();
}
```
Or, an example using the directive with CommonJS
```javascript
// utils.js
"use k6 with k6/x/redis"
const redis = require('k6/x/redis');

exports.helper = function() {
  // Use redis extension
}
```

In this example, k6 will detect both `k6/x/faker` and `k6/x/redis` extensions from the `use k6` directives in both files and provision a binary that includes both extensions if needed.

Other fixes this brings are:
1. Fixes for path related issues (irregardless of usage of the feature) on windows, especially between drives. It is possible there were problems on other OSes that were just not reported. [#5176](https://github.com/grafana/k6/issues/5176)
2. Syntax errors were not reported as such, as the underlying `esbuild` parsing will fail, but won't be handled well. [#5127](https://github.com/grafana/k6/issues/5127), [#5104](https://github.com/grafana/k6/issues/5104)

3. Propagating exit codes from a sub-process running the new k6. This lets you use the result of the exit code.
