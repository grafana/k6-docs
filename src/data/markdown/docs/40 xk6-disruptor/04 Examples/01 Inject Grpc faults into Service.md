---
title: 'Inject gRPC faults into Service'
excerpt: ''
---

This example shows how [ServiceDisruptor](/javascript-api/xk6-disruptor/api/servicedisruptor) can be used for testing the effect of faults injected in the gRPC requests served by a service.

You will find the complete [source code](#source-code) at the end of this document. Next sections examine the code in detail.

The example uses [grpcpbin](https://grpcb.in), a simple request/response application that offers endpoints for testing different gRPC requests.

The test requires `grpcpbin` to be deployed in a cluster in the namespace `grpcbin` and exposed with an external IP. the IP address is expected in the environment variable `GRPC_HOST`.

You will find the Kubernetes manifests and the instructions of how to deploy it to a cluster in the [test setup](#test-setup) section at the end of this document. You can learn more about how to get the external IP address in the [expose your application](/javascript-api/xk6-disruptor/get-started/expose-your-application) section.


## Initialization

The initialization code imports the external dependencies required by the test. The [ServiceDisruptor](https://k6.io/docs/javascript-api/xk6-disruptor/api/servicedisruptor/) class imported from the `xk6-disruptor` extension provides functions for injecting faults in pods. The [k6/net/grpc](https://k6.io/docs/javascript-api/k6-net-grpc/) module provides functions for executing gRPC requests. We will also use the [check](https://k6.io/docs/javascript-api/k6/check/) function to verify the results from the requests.


```javascript
import { ServiceDisruptor } from 'k6/x/disruptor';
import grpc from 'k6/net/grpc';
import { check } from 'k6';
 ```

We also create a grpc client and load the protobufs definitions for the [HelloService](https://github.com/moul/pb/blob/master/hello/hello.proto) service.


```javascript
const client = new grpc.Client();
client.load(['pb'], 'hello.proto');
```

## Test Load

The test load is generated by the `default` function, which connects to the `grpcbin` service using the IP and port obtained from the environment variable `GRPC_HOST` and invokes the `SayHello` method of the `hello.HelloService` service. Finally, The status code of the response is checked. When faults are injected, this check should fail.

```javascript
export default function () {
    client.connect(
        __ENV.GRPC_HOST,
        {
            plaintext: true,
            timeout: '1s'
        }
    );
    
    const data = { greeting: 'Bert' };
    const response = client.invoke(
        'hello.HelloService/SayHello',
        data,
        {
            timeout: '1s'
        }
    );
    client.close()

    check(response, {
        'status is OK': (r) => r && r.status === grpc.StatusOK,
    });

}
 ```

## Fault injection

The `disrupt` function creates a `ServiceDisruptor` for the `grpcbin` service in the namespace `grpcbin`.

The gRPC faults are injected by calling the [ServiceDisruptor.injectGrpcFaults](/javascript-api/xk6-disruptor/api/servicedisruptor/injectgrpcfaults) method using a fault definition that introduces a delay of `300ms` on each request and an error with status code `13` ("Internal error") in `10%` of the requests.


```javascript
export function disrupt() {
    if (__ENV.SKIP_FAULTS == "1") {
        return
    }

    const fault = {
        averageDelay: 300,
        statusCode: grpc.StatusInternal,
        errorRate: 0.1,
        port: 9000,
    }
    const disruptor = new ServiceDisruptor('grpcbin','grpcbin')
    disruptor.injectGrpcFaults(fault, 30)
}
```

Notice the following code snippet in the `injectFaults` function above:

```javascript
   if (__ENV.SKIP_FAULTS == "1") {
       return
   }
```

This code makes the function return without injecting faults if the `SKIP_FAULTS` environment variable is passed to the execution of the test with a value of "1". We will use this option to obtain a [baseline execution](#baseline-execution) without faults.

## Scenarios 

This test defines two [scenarios](https://k6.io/docs/using-k6/scenarios) to be executed. The `load` scenario applies the test load to the `grpcpbin` application for `30s` invoking the `default` function. The `disrupt` scenario invokes the `disrupt` function to inject a fault in the gRPC requests to the target application.

```javascript
    scenarios: {
        load: {
            executor: 'constant-arrival-rate',
            rate: 100,
            preAllocatedVUs: 10,
            maxVUs: 100,
            exec: "default",
            startTime: '0s',
            duration: "30s",
        },
        disrupt: {
            executor: 'shared-iterations',
            iterations: 1,
            vus: 1,
            exec: "disrupt",
            startTime: "0s",
        }
    }
 ```

 <Blockquote mod="note">

 Notice that the `disrupt` scenario uses a `shared-iterations` executor with one iteration and one `VU`. This setting ensures the `disrupt` function is executed only once. Executing this function multiples times concurrently may have unpredictable results.

</Blockquote>


## Executions

<Blockquote mod="note">

The commands in this section assume the `xk6-disruptor` binary is available in your current directory. This location can change depending on the installation process and the platform. Refer to the [installation section](/javascript-api/xk6-disruptor/get-started/installation) for details on how to install it in your environment.

</Blockquote>

### Baseline execution

We will first execute the test without introducing faults to have an baseline using the following command:

<CodeGroup labels={["Linux/MacOS", "Windows PowerShell"]}>

```bash
xk6-disruptor --env SKIP_FAULTS=1 --env GRPC_HOST=$GRPC_HOST run grpc-faults.js
```

```PowerShell
xk6-disruptor --env SKIP_FAULTS=1 --env "GRPC_HOST=$Env:GRPC_HOST" run grpc-faults.js
```

</CodeGroup>

Notice the argument `--env SKIP_FAULT=1`, which makes the `disrupt` function return without injecting any fault as explained in the [fault injection](#fault-injection) section. Also notice the `--env GRPC_HOST` argument, which passes the external IP used to access the `grpcbin` application.

You should get an output similar to the one shown below (click `Expand` button to see all output).

<CodeGroup heightTogglers="true">

```
          /\      |‾‾| /‾‾/   /‾‾/   
     /\  /  \     |  |/  /   /  /    
    /  \/    \    |     (   /   ‾‾\  
   /          \   |  |\  \ |  (‾)  | 
  / __________ \  |__| \__\ \_____/ .io

  execution: local
     script: scripts/grpc-faults.js
     output: -

  scenarios: (100.00%) 2 scenarios, 101 max VUs, 10m30s max duration (incl. graceful stop):
           * disrupt: 1 iterations shared among 1 VUs (maxDuration: 10m0s, exec: disrupt, gracefulStop: 30s)
           * load: 100.00 iterations/s for 30s (maxVUs: 10-100, exec: default, gracefulStop: 30s)


running (00m30.0s), 000/011 VUs, 3001 complete and 0 interrupted iterations
disrupt ✓ [======================================] 1 VUs        00m00.0s/10m0s  1/1 shared iters
load    ✓ [======================================] 000/010 VUs  30s             100.00 iters/s

     ✓ status is OK

     checks...............: 100.00% ✓ 3000       ✗ 0   
     data_received........: 416 kB  14 kB/s
     data_sent............: 630 kB  21 kB/s
     grpc_req_duration....: avg=1.36ms min=512.43µs med=1.25ms max=26.62ms p(90)=1.75ms p(95)=2.09ms
     iteration_duration...: avg=4.4ms  min=52.86µs  med=4.01ms max=66.26ms p(90)=5.32ms p(95)=6.35ms
     iterations...........: 3001    100.028406/s
     vus..................: 10      min=10       max=10
     vus_max..............: 11      min=11       max=11
```
</CodeGroup >


### Fault injection

We repeat the execution injecting the faults. Notice we have removed the `--env SKIP_FAULTS=1` argument.

<CodeGroup labels={["Linux/MacOS", "Windows PowerShell"]}>

```bash
xk6-disruptor --env GRPC_HOST=$GRPC_HOST run grpc-faults.js
```

```PowerShell
xk6-disruptor --env "GRPC_HOST=$Env:GRPC_HOST" run grpc-faults.js
```

</CodeGroup >

<CodeGroup heightTogglers="true">

```
           /\      |‾‾| /‾‾/   /‾‾/   
     /\  /  \     |  |/  /   /  /    
    /  \/    \    |     (   /   ‾‾\  
   /          \   |  |\  \ |  (‾)  | 
  / __________ \  |__| \__\ \_____/ .io

  execution: local
     script: scripts/grpc-faults.js
     output: -

  scenarios: (100.00%) 2 scenarios, 101 max VUs, 10m30s max duration (incl. graceful stop):
           * disrupt: 1 iterations shared among 1 VUs (maxDuration: 10m0s, exec: disrupt, gracefulStop: 30s)
           * load: 100.00 iterations/s for 30s (maxVUs: 10-100, exec: default, gracefulStop: 30s)


running (00m50.6s), 000/033 VUs, 2975 complete and 0 interrupted iterations
disrupt ✓ [======================================] 1 VUs        00m50.6s/10m0s  1/1 shared iters
load    ✓ [======================================] 000/032 VUs  30s             100.00 iters/s

     ✗ status is OK
      ↳  89% — ✓ 2668 / ✗ 306

     checks...............: 89.71% ✓ 2668      ✗ 306 
     data_received........: 405 kB 8.0 kB/s
     data_sent............: 615 kB 12 kB/s
     dropped_iterations...: 26     0.513628/s
     grpc_req_duration....: avg=270.51ms min=502.12µs med=302.34ms max=310.48ms p(90)=303.25ms p(95)=303.57ms
     iteration_duration...: avg=290.05ms min=1.96ms   med=304.86ms max=50.61s   p(90)=306.36ms p(95)=306.89ms
     iterations...........: 2975   58.770842/s
     vus..................: 1      min=1       max=33
     vus_max..............: 33     min=25      max=33
```
</CodeGroup >

### Comparison

Let's take a closer look at the results for the requests on each scenario. We can observe that in the `base` scenario requests duration has an percentile 95 of `2.09ms` and `100%` of requests pass the check. The `faults` scenario has a percentile 96 of `303.57ms` and only `89%` of requests pass the check (or put in another way, `11%` of requests failed), closely matching the fault definition.

| Execution       | P95 Req. Duration |  Passed Checks |
| --------------- | ----------------- | -------------- |
| Baseline        | 2.09ms            | 100%           |
| Fault injection | 303.57ms          | 89%            |


## Source Code

<Collapsible title="grpc-faults.js">

```javascript
import { ServiceDisruptor } from 'k6/x/disruptor';
import grpc from 'k6/net/grpc';
import { check } from 'k6';

const client = new grpc.Client();
client.load(['pb'], 'hello.proto');

export default function () {
    client.connect(
        __ENV.GRPC_HOST,
        {
            plaintext: true,
            timeout: '1s'
        }
    );
    
    const data = { greeting: 'Bert' };
    const response = client.invoke(
        'hello.HelloService/SayHello',
        data,
        {
            timeout: '1s'
        }
    );
    client.close()

    check(response, {
        'status is OK': (r) => r && r.status === grpc.StatusOK,
    });

}

export function disrupt() {
    if (__ENV.SKIP_FAULTS == "1") {
        return
    }

    const disruptor = new ServiceDisruptor('grpcbin','grpcbin')

    // inject errors in requests
    const fault = {
        averageDelay: 300,
        statusCode: grpc.StatusInternal,
        errorRate: 0.1,
        port: 9000,
    }
    disruptor.injectGrpcFaults(fault, 30)
}

export const options = {
    scenarios: {
        load: {
            executor: 'constant-arrival-rate',
            rate: 100,
            preAllocatedVUs: 10,
            maxVUs: 100,
            exec: "default",
            startTime: '0s',
            duration: "30s",
        },
        disrupt: {
            executor: 'shared-iterations',
            iterations: 1,
            vus: 1,
            exec: "disrupt",
            startTime: "0s",
        }
    }
}
```
</Collapsible>


<Collapsible title="pb/hello.proto">

```
syntax = "proto2";

package hello;

service HelloService {
  rpc SayHello(HelloRequest) returns (HelloResponse);
  rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
  rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
  rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
}

message HelloRequest {
  optional string greeting = 1;
}

message HelloResponse {
  required string reply = 1;
}
```

</Collapsible>

## Test setup

The tests requires the deployment of the `grpcbin` application. The application must also be accessible using an external IP available in the `GRPC_HOST` environment variable.

The [manifests](#manifests) below define the resources required for deploying the application and exposing it as a LoadBalancer service.

You can deploy the application using the following commands:

```bash
# Create Namespace
kubectl apply -f namespace.yaml
namespace/grpcbin created

# Deploy Pod
kubectl apply -f pod.yaml
pod/grpcbin created

# Expose Pod as a Service
kubectl apply -f service.yaml
service/grpcbin created
```

You must set the environment variable `GRPC_HOST` with the external IP address and port used to access the `grpcbin` service from the test script. 

You can learn more about how to get the external IP address in the [expose your application](/javascript-api/xk6-disruptor/get-started/expose-your-application) section.

### Manifests

<Collapsible title="namespace.yaml">

```yaml
apiVersion: "v1"
kind: Namespace
metadata:
  name: grpcbin
```

</Collapsible>

<Collapsible title="pod.yaml">

```yaml
kind: "Pod"
apiVersion: "v1"
metadata:
  name: grpcbin
  namespace: grpcbin
  labels:
    app: grpcbin
spec:
  containers:
  - name: grpcbin
    image: moul/grpcbin
    ports:
    - name: http
      containerPort: 9000

```

</Collapsible>


<Collapsible title="service.yaml">

```yaml
apiVersion: "v1"
kind: "Service"
metadata:
  name: grpcbin
  namespace: grpcbin
spec:
  selector:
    app: grpcbin
  type: "NodePort"
  ports:
  - port: 9000
    targetPort: 9000
```

</Collapsible>

