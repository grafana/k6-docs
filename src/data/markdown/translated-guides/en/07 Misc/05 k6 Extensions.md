---
title: 'k6 Extensions'
---

> *Since v0.29.0 (JavaScript extensions) and v0.31.0 (Output extensions)*

Traditionally, extending k6 with custom functionality that isn't available in the
open source tool has been possible in one of two ways:

- By importing a JavaScript library. This is a simple way to extend the functionality
  of a test script, though it has some drawbacks. Since JavaScript in k6 runs in a
  virtual machine [that is unlike the one used in web browsers and
  NodeJS](/#what-k6-does-not), it's not possible to use libraries that write to
  disk, use JS APIs other than the ones built into k6, or need some new binary
  protocol support. Furthermore, while k6 performs well in most use cases, all
  execution is interpreted by the [Go JavaScript runtime](https://github.com/dop251/goja),
  which can impact the performance of certain resource intensive operations
  (cryptography, compression, etc.).

- By forking the [k6 repository](https://github.com/k6io/k6), doing the changes in Go
  and submitting a pull request for review by the core team (preferably following
  the [contribution guidelines](https://github.com/k6io/k6/blob/master/CONTRIBUTING.md)).
  This is a great way to contribute new core features, but it can be a lengthy
  process, and submissions might be rejected if they don't align with the long-term
  vision of the project.

To address these issues and allow the community to more easily adapt k6 to fit their
needs, [k6 v0.29.0](https://github.com/k6io/k6/releases/tag/v0.29.0) introduced
the [xk6 framework](https://github.com/k6io/xk6) and the concept of k6 extensions.


## What are k6 extensions?

k6 extensions are standalone Go projects that call k6 APIs but are otherwise
unrestricted in their functionality. This provides the freedom for extension authors
to experiment with novel integrations with k6 that could eventually easily become
part of core. In this sense extensions can be thought of as a "testing ground" for
eventual promotion upstream, once their features and API is stable, and given that
the extension is generally useful for all k6 users.


## What is xk6?

[xk6](https://github.com/k6io/xk6) is a command-line tool and framework inspired by
[xcaddy](https://github.com/caddyserver/xcaddy), designed for building custom k6
binaries that bundle one or more extensions written in Go.

Its main features are:

- Ease of use: with a few commands even less technical users should be able to build
  their own k6 binaries, given that they have the Go toolchain installed and any
  dependencies required by a specific extension.
- Simple API for Go programmers that handles the Go<->JS translation, with the
  ability to call any public k6 Go API. Extensions are first-class components along
  with other built-in modules.
- Cross-platform like Go and runs great on macOS, Windows and Linux.


### Extension types

The initial version of xk6 released in v0.29.0 supported only JavaScript extensions,
but since then we've added support for Output extensions, and are considering
expanding this to other areas of k6 as well.

The currently supported extension types are:

#### JavaScript extension

These extensions enhance the k6 JavaScript API to add support for new network
protocols, achieve better performance than equivalent JS libraries, or implement
features that are unlikely to be made part of the k6 core.

Some examples include: [xk6-sql](https://github.com/imiric/xk6-sql),
[xk6-crypto](https://github.com/szkiba/xk6-crypto) and [xk6-file](https://github.com/avitalique/xk6-file).


#### Output extension

While k6 has built-in support for many popular [output
backends](/docs/getting-started/results-output/), this list will undoubtedly not be
exhaustive. Support for new systems and novel ways of handling the metric data
generated by k6 can be easily added with Output extensions. These receive metric
samples from k6, and are able to do any processing or further dispatching.

Some examples include: [xk6-prometheus](https://github.com/szkiba/xk6-prometheus)
and [xk6-influxdbv2](https://github.com/li-zhixin/xk6-influxdbv2).


## Getting started

There are two ways in which xk6 can be used:

- By k6 users that wish to enhance their tests with existing extensions. A
  familiarity with the command line and Go is preferred, but not required.

- By Go developers interested in creating their own k6 extension. They'll need to be
  familiar with both Go and JavaScript, understand how the k6 Go<->JS bridge works,
  and maintain a public repository for the extension that keeps up to date with any
  breaking API changes while xk6 is being stabilized.

<!-- This used to be an h3 (nested under "Getting Started"), but h5s aren't styled -->
<!-- properly and the right side index doesn't show sections above h2, so this is -->
<!-- at the same level now. :-/ -->
## Using xk6 to build a k6 binary

You might have found a neat k6 extension on the [Ecosystem page](/ecosystem) or on
[GitHub](https://github.com/topics/xk6) and wish to use it in your tests. Great! The
process is relatively simple and we're working on simplifying it further for end
users.

You'll first need to setup [Go](https://golang.org/doc/install) and
[Git](https://git-scm.com/). Make sure that your `$PATH` environment variable is
updated and that `go version` returns the correct version.

Then install xk6 with:

<CodeGroup labels={[]} lineNumbers={[false]}>

```bash
$ go install github.com/k6io/xk6/cmd/xk6@latest
```

</CodeGroup>

And confirm that `which xk6` on Linux/macOS or `where xk6` on Windows returns a
valid path. Otherwise ensure that `$GOPATH` is correctly defined and that
`$GOPATH/bin` is added to your `$PATH` environment variable. See the
[Go documentation](https://golang.org/cmd/go/#hdr-GOPATH_environment_variable) for details.

Once xk6 is installed, building a k6 binary with one or more extensions can be done
with the following command:

<CodeGroup labels={[]} lineNumbers={[false]}>

```bash
$ xk6 build v0.33.0 \
  --with github.com/imiric/xk6-sql \
  --with github.com/szkiba/xk6-prometheus
```

</CodeGroup>

This will build a `k6` binary in the current directory based on k6 v0.33.0, bundling
a JavaScript and an Output extension. Now you can run a script with this binary that
uses the [`xk6-sql` JS API](https://github.com/imiric/xk6-sql) and the
[Prometheus output](https://github.com/szkiba/xk6-prometheus).

Note that when running the script we have to specify the binary just built in the
current directory (`./k6`), as otherwise some other `k6` binary found on the system
could be executed which might not have the extensions built-in. This is only the case
on Linux and macOS, as Windows shells will execute the binary in the current
directory first.


## Writing a new extension

The first thing you should do before starting work on a new extension is to confirm
that a similar extension doesn't already exist for your use case. Take a look at
the [Ecosystem page](/ecosystem) and the [`xk6` topic on GitHub](https://github.com/topics/xk6).
For example, if a system you need support for can be tested with a generic protocol
like MQTT, prefer using [xk6-mqtt](https://github.com/pmalhaire/xk6-mqtt)
instead of creating an extension that uses some custom protocol.

Next, you should decide the type of extension you need. A JavaScript extension is a
good fit if you want to extend the JS functionality of your script, or add support
for a new network protocol to test with. An Output extension would be more suitable
if you need to process the metrics emitted by k6 in some way, submit them to a
specific storage backend that was previously unsupported, etc. The k6 APIs you'll
need to use and things to consider while developing will be different in each case.


### Writing a new JavaScript extension

A good starting point for using xk6 and writing a JS extension is the [xk6
introductory article](https://k6.io/blog/extending-k6-with-xk6), but we'll cover
some of the details here.

JavaScript extensions consist of a main module struct that exposes methods that
can be called from a k6 test script. For example:

<!-- TODO: A better trivial example? -->

<CodeGroup labels={["compare.go"]} lineNumbers={[false]}>

```go
package compare

type Compare struct{}

func (*Compare) IsGreater(int a, b) bool {
	return a > b
}
```

</CodeGroup>

In order to use this from k6 test scripts we need to register the module
by adding the following:

<CodeGroup labels={["compare.go"]} lineNumbers={[false]}>

```go
import "go.k6.io/k6/js/modules"

func init() {
	modules.Register("k6/x/compare", new(Compare))
}
```

</CodeGroup>

Note that all k6 extensions should have the `k6/x/` prefix and the short name
must be unique among all extensions built in the same k6 binary.

We can then build a k6 binary with this extension by running
`xk6 build --with xk6-compare=.`. In this case `xk6-compare` is the
Go module name passed to `go mod init`, but in a real-world scenario
this would be a URL.

Finally we can use the extension in a test script:

<CodeGroup labels={["test.js"]} lineNumbers={[true]}>

```go
import compare from 'k6/x/compare';

export default function () {
  console.log(compare.isGreater(2, 1));
}
```

</CodeGroup>

And run the test with `./k6 run test.js`, which should output `INFO[0000] true`.


#### Additional features

The k6 Go-JS bridge has a few features we should highlight:

- Go method names will be converted from Pascal case to Camel case when
  accessed in JS, as in the example above: `IsGreater` becomes `isGreater`.

<!-- FIXME: Markdown magic to escape backticks in Go struct tags? <pre> doesn't work... -->
- Similarly, Go field names will be converted from Pascal case to Snake case.
  For example, the struct field `SomeField string` is accessible in JS
  as the `some_field` object property. This behavior is configurable with the
  `js` struct tag, so this can be changed with `SomeField string ``js:"someField"```
  or the field can be hidden with `js:"-"`.

- Method names prefixed with `X` are interpreted as constructors in JS,
  and will support the `new` operator.
  For example, defining the following method on the above struct:

<CodeGroup labels={["compare.go"]} lineNumbers={[false]}>

```go
func (*Compare) XComparator() *Comparator {
	return &Comparator{}
}
```

</CodeGroup>

  Would allow creating a `Comparator` instance in JS with `new compare.Comparator()`,
  which is a bit more idiomatic to JS.

- Methods that specify `context.Context` or `*context.Context` as the first
  argument will be passed the `Context` instance used internally in k6,
  which has attached some useful objects for inspecting the internal execution
  state, such as
  [`lib.State`](https://github.com/grafana/k6/blob/v0.33.0/lib/state.go#L43)
  or VU state, [`lib.ExecutionState`](https://github.com/grafana/k6/blob/v0.33.0/lib/execution.go#L142),
  and the [`goja.Runtime`](https://github.com/dop251/goja/blob/705acef95ba3654f89c969d9e792ac5f49215350/runtime.go#L162) instance
  the VU is using to execute the script.
  This feature is used extensively in the
  [`xk6-execution`](https://github.com/grafana/xk6-execution) extension.

<!-- TODO: Mention common.Bind() here? HasModuleInstancePerVU? -->


#### Things to keep in mind

- The code in the `default` function (or another function specified by
  [`exec`](/using-k6/scenarios/#common-options)) will be executed many
  times during a test run and possibly in parallel by thousands of VUs.
  As such any operation of your extension meant to run in that context
  needs to be performant and [thread-safe](https://en.wikipedia.org/wiki/Thread_safety).
- Any heavy initialization should be done in the [`init`
  context](/javascript-api/init-context/)...
- Custom metric emission can be done by creating new metrics using
  [`stats.New()`](https://github.com/grafana/k6/blob/v0.33.0/stats/stats.go#L449)
  and emitting them using [`stats.PushIfNotDone()`](https://github.com/grafana/k6/blob/v0.33.0/stats/stats.go#L429).
  For an example of this see the [`xk6-remote-write` extension](https://github.com/dgzlopes/xk6-remote-write).


### Writing a new Output extension

Output extensions are similarly written, but have a different API and performance
considerations.

The core of an Output extension is a struct that implements the [`output.Output`
interface](https://github.com/grafana/k6/blob/v0.33.0/output/types.go#L57). For example:

<CodeGroup labels={["log.go"]} lineNumbers={[false]}>

```go
package log

import (
	"fmt"
	"io"

	"go.k6.io/k6/output"
	"go.k6.io/k6/stats"
)

// Register the extension on module initialization.
func init() {
	output.RegisterExtension("logger", New)
}

// Logger writes k6 metric samples to stdout.
type Logger struct {
	out io.Writer
}

// New returns a new instance of Logger.
func New(params output.Params) (output.Output, error) {
	return &Logger{params.StdOut}, nil
}

// Description returns a short human-readable description of the output.
func (*Logger) Description() string {
	return "logger"
}

// Start initializes any state needed for the output, establishes network
// connections, etc.
func (o *Logger) Start() error {
	return nil
}

// AddMetricSamples receives metric samples from the k6 Engine as they're
// emitted and prints them to stdout.
func (l *Logger) AddMetricSamples(samples []stats.SampleContainer) {
	for i := range samples {
		all := samples[i].GetSamples()
		for j := range all {
			fmt.Fprintf(l.out, "%d %s: %f\n", all[j].Time.UnixNano(), all[j].Metric.Name, all[j].Value)
		}
	}
}

// Stop finalizes any tasks in progress, closes network connections, etc.
func (*Logger) Stop() error {
	return nil
}
```

</CodeGroup>

Notice a couple of things:

- The module initializer `New()` receives an instance of
  [`output.Params`](https://github.com/grafana/k6/blob/v0.33.0/output/types.go#L36).
  With this object the extension can access the output-specific configuration,
  interfaces to the filesystem, synchronized stdout and stderr, and more.
- `AddMetricSamples` in this example simply writes to stdout. In a real-world
  scenario this output might have to be buffered and flushed periodically to avoid
  memory leaks. Below we'll discuss some helpers you can use for that.


#### Additional features

- Output structs can optionally implement additional interfaces that allows them to
  [receive thresholds](https://github.com/grafana/k6/blob/v0.33.0/output/types.go#L79),
  [test run status updates](https://github.com/grafana/k6/blob/v0.33.0/output/types.go#L94)
  or [interrupt a test run](https://github.com/grafana/k6/blob/v0.33.0/output/types.go#L88).
- Because output implementations typically need to process large amounts of data that
  k6 produces and dispatch it to another system, we've provided a couple of helper
  structs you can use in your extensions:
  [`output.SampleBuffer`](https://github.com/grafana/k6/blob/v0.33.0/output/helpers.go#L35)
  is a thread-safe buffer for metric samples to help with memory management and
  [`output.PeriodicFlusher`](https://github.com/grafana/k6/blob/v0.33.0/output/helpers.go#L75)
  will periodically run a function which is useful for flushing or dispatching the
  buffered samples.
  For usage examples see the [`statsd` output](https://github.com/k6io/k6/blob/v0.33.0/output/statsd/output.go#L55).
